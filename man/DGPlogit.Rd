% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DGPlogit.r
\name{DGPlogit}
\alias{DGPlogit}
\title{Data Generating Process for Binary Logistic Regression}
\usage{
DGPlogit(N, beta, corr = c("indep", "ar1", "exp", "user"), rho = NULL,
  phi = NULL, R = NULL, mu = 0, sd = 1, margins = "gaussian",
  df = 5, unif_min = 0, unif_max = 1, bernoulli_p = 0.5,
  standardize = FALSE, include_intercept_col = FALSE,
  target_prevalence = NULL, intercept_bounds = c(-20, 20), seed = NULL)
}
\arguments{
\item{N}{Integer. Number of observations.}

\item{beta}{Numeric vector of coefficients including the intercept
(length \eqn{K+1}). The first element is the intercept, followed by
slopes for each of the \eqn{K} predictors.}

\item{corr}{Correlation structure among predictors. One of:
\code{"indep"} (independent predictors),
\code{"ar1"} (AR(1) with parameter \code{rho}),
\code{"exp"} (exponential with decay \code{phi}),
or \code{"user"} (user-specified correlation matrix \code{R}).}

\item{rho}{Numeric scalar in (-1, 1). Correlation parameter for AR(1).}

\item{phi}{Positive scalar. Decay parameter for exponential correlation.}

\item{R}{User-supplied correlation matrix (\eqn{K \times K}) if
\code{corr = "user"}.}

\item{mu}{Numeric vector of means for margins (recycled to length K).
For Gaussian/t margins, used as mean; for lognormal, used as \code{meanlog}.}

\item{sd}{Numeric vector of standard deviations (recycled to length K).
For Gaussian/t margins, used as scale; for lognormal, used as \code{sdlog}.}

\item{margins}{Character vector of length K specifying marginal distributions
for each predictor. Options: \code{"gaussian"}, \code{"t"},
\code{"lognormal"}, \code{"uniform"}, \code{"bernoulli"}.}

\item{df}{Degrees of freedom for t margins (scalar or length K).}

\item{unif_min, unif_max}{Lower and upper bounds for uniform margins
(scalars or length K).}

\item{bernoulli_p}{Success probability for Bernoulli margins
(scalar or length K).}

\item{standardize}{Logical. If \code{TRUE}, continuous predictors are centered
and scaled to unit variance.}

\item{include_intercept_col}{Logical. If \code{TRUE}, an intercept column of 1
is prepended to \code{X}.}

\item{target_prevalence}{Optional numeric scalar in (0, 1). If provided,
the intercept is shifted so that the simulated prevalence
\eqn{E[y]} matches \code{target_prevalence} (within tolerance).}

\item{intercept_bounds}{Numeric length-2 vector. Interval in which to search
for the intercept shift when calibrating prevalence.}

\item{seed}{Optional integer random seed for reproducibility.}
}
\value{
A list of class \code{"DGPlogit"} with components:
\itemize{
  \item \code{X}: Simulated design matrix (\eqn{N \times K}, or \eqn{N \times (K+1)}
    if \code{include_intercept_col=TRUE}).
  \item \code{y}: Binary outcome vector of length N.
  \item \code{p}: Vector of success probabilities.
  \item \code{eta}: Linear predictor.
  \item \code{beta}: Coefficient vector (with intercept).
  \item \code{slopes}, \code{intercept}, \code{intercept_shift}.
  \item \code{R_used}: Correlation matrix actually used.
  \item \code{margins}, \code{mu}, \code{sd}, \code{df}, \code{unif_min},
    \code{unif_max}, \code{bernoulli_p}: Margin specifications.
  \item \code{corr}, \code{rho}, \code{phi}: Correlation info.
  \item \code{standardize}, \code{include_intercept_col}, \code{target_prevalence}.
  \item \code{seed}: RNG seed if set.
}
}
\description{
\code{DGPlogit()} simulates binary outcomes from a logistic regression model
with flexible correlation structures and user-specified marginal distributions
for predictors. Predictors are generated via a Gaussian copula to enforce a
desired correlation matrix while allowing heterogeneous margins.
}
\details{
The function generates latent Gaussian vectors \eqn{Z_i \sim N(0, R)} for
each observation, where \eqn{R} is the correlation matrix implied by
\code{corr}, \code{rho}, \code{phi}, or provided as \code{R}.
These are transformed to uniform \eqn{U_i = \Phi(Z_i)} and then mapped into
the specified marginal distributions via their inverse CDFs.

The linear predictor is
\deqn{\eta = \beta_0 + X \beta,}
with success probability
\deqn{p = \frac{1}{1 + \exp(-\eta)}.}
Outcomes \code{y} are drawn as \code{Bernoulli(p)}.

If \code{target_prevalence} is provided, the intercept \eqn{\beta_0}
is shifted by solving
\deqn{\frac{1}{N}\sum_i \text{logit}^{-1}(\eta_i + \delta) = \text{target\_prevalence}}
for \eqn{\delta} via root-finding within \code{intercept_bounds}.
}
\examples{
# Example 1: Gaussian independent predictors
set.seed(1)
sim1 <- DGPlogit(N=1000, beta=c(-0.5, 1, -0.8, 0.6),
                 corr="indep", margins="gaussian")

# Example 2: AR(1) correlation, mixed margins
sim2 <- DGPlogit(N=500, beta=c(0.2, 0.5, -1, 0.8),
                 corr="ar1", rho=0.5,
                 margins=c("gaussian","t","bernoulli"),
                 df=5, bernoulli_p=0.3, standardize=TRUE)

# Example 3: Target prevalence calibration
sim3 <- DGPlogit(N=1000, beta=c(0, 1, -1),
                 corr="exp", phi=0.7,
                 target_prevalence=0.25)
#' @seealso \code{\link[stats]{optim}}, \code{\link[stats]{rbinom}}, \code{\link[stats]{qnorm}}

}
